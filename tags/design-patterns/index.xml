<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Patterns on SivaLabs</title>
    <link>http://sivalabs.github.io/tags/design-patterns/</link>
    <description>Recent content in Design Patterns on SivaLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Jun 2012 07:50:00 +0000</lastBuildDate>
    <atom:link href="http://sivalabs.github.io/tags/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How I explained Dependency Injection to My Team</title>
      <link>http://sivalabs.github.io/post/2012/how-i-explained-dependency-injection-to-my-team/</link>
      <pubDate>Tue, 19 Jun 2012 07:50:00 +0000</pubDate>
      
      <guid>http://sivalabs.github.io/post/2012/how-i-explained-dependency-injection-to-my-team/</guid>
      <description>&lt;p&gt;Recently our company started developing a new java based web application and after some evaluation process we decided to use Spring.&lt;/p&gt;

&lt;p&gt;But many of the team members are not aware of Spring and Dependency Injection principles.&lt;br /&gt;
So I was asked to give a crash course on what is Dependency Injection and basics on Spring.&lt;/p&gt;

&lt;p&gt;Instead of telling all the theory about IOC/DI I thought of explaining with an example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Requirement:&lt;/strong&gt; We will get some Customer Address and we need to validate the address.&lt;br /&gt;
After some evaluation we thought of using Google Address Validation Service.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Legacy(Bad) Approach:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Just create an AddressVerificationService class and implement the logic.&lt;/p&gt;

&lt;p&gt;Assume GoogleAddressVerificationService is a service provided by Google which takes Address as a String and Return longitude/latitude.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AddressVerificationService &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;{&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   public String validateAddress(String address)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; GoogleAddressVerificationService gavs = new GoogleAddressVerificationService();&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  String result = gavs.validateAddress(address);  &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return result;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;}&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**Issues with this approach: **&lt;br /&gt;
1. If you want to change your Address Verification Service Provider you need to change the logic.&lt;br /&gt;
2. You can&amp;rsquo;t Unit Test with some Dummy AddressVerificationService (Using Mock Objects)&lt;/p&gt;

&lt;p&gt;Due to some reason Client ask us to support multiple AddressVerificationService Providers and we need to determine which service to use at runtime.&lt;/p&gt;

&lt;p&gt;To accomidate this you may thought of changing the above class as below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AddressVerificationService&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;{&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;//This method validates the given address and return longitude/latitude details.&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public String validateAddress(String address)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  String result = null;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  int serviceCode = 2; // read this code value from a config file&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(serviceCode == 1)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   GoogleAddressVerificationService googleAVS = new GoogleAddressVerificationService();&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   result = googleAVS.validateAddress(address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  } else if(serviceCode == 2)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   YahooAddressVerificationService yahooAVS = new YahooAddressVerificationService();&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   result = yahooAVS.validateAddress(address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return result;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;}&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**Issues with this approach: **&lt;br /&gt;
**&lt;br /&gt;
**&lt;br /&gt;
1. Whenever you need to support a new Service Provider you need to add/change logic using if-else-if.&lt;br /&gt;
2. You can&amp;rsquo;t Unit Test with some Dummy AddressVerificationService (Using Mock Objects)&lt;/p&gt;

&lt;p&gt;** IOC/DI Approach: **&lt;/p&gt;

&lt;p&gt;In the above approaches AddressVerificationService is taking the control of creating its dependencies.&lt;br /&gt;
So whenever there is a change in its dependencies the AddressVerificationService will change.&lt;/p&gt;

&lt;p&gt;Now let us rewrite the AddressVerificationService using IOC/DI pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class AddressVerificationService&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  private AddressVerificationServiceProvider serviceProvider;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public AddressVerificationService(AddressVerificationServiceProvider serviceProvider) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   this.serviceProvider = serviceProvider;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public String validateAddress(String address)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   return this.serviceProvider.validateAddress(address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; interface AddressVerificationServiceProvider&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public String validateAddress(String address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are injecting the AddressVerificationService dependency AddressVerificationServiceProvider.&lt;/p&gt;

&lt;p&gt;Now let us implement the AddressVerificationServiceProvider with multiple provider services.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class YahooAVS implements AddressVerificationServiceProvider&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  @Override&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public String validateAddress(String address) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   System.out.println(&amp;quot;Verifying address using YAHOO AddressVerificationService&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   return yahooAVSAPI.validate(address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }  &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; class GoogleAVS implements AddressVerificationServiceProvider&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  @Override&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public String validateAddress(String address) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   System.out.println(&amp;quot;Verifying address using Google AddressVerificationService&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   return googleAVSAPI.validate(address);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the Client can choose which Service Provider&amp;rsquo;s service to use as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; AddressVerificationService verificationService = null;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; AddressVerificationServiceProvider provider = null;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; provider = new YahooAVS();//to use YAHOO AVS&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; provider = new GoogleAVS();//to use Google AVS&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; verificationService = new AddressVerificationService(provider);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; String lnl = verificationService.validateAddress(&amp;quot;HitechCity, Hyderabad&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; System.out.println(lnl);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Unit Testing we can implement a Mock AddressVerificationServiceProvider.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class MockAVS implements AddressVerificationServiceProvider&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  @Override&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  public String validateAddress(String address) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   System.out.println(&amp;quot;Verifying address using MOCK AddressVerificationService&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   return &amp;quot;&amp;lt;response&amp;gt;&amp;lt;longitude&amp;gt;123&amp;lt;/longitude&amp;gt;&amp;lt;latitude&amp;gt;4567&amp;lt;/latitude&amp;gt;&amp;quot;;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; AddressVerificationServiceProvider provider = null;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; provider = new MockAVS();//to use MOCK AVS  &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; AddressVerificationServiceIOC verificationService = new AddressVerificationServiceIOC(provider);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; String lnl = verificationService.validateAddress(&amp;quot;Somajiguda, Hyderabad&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; System.out.println(lnl);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this approach we elemenated the issues with above Non-IOC/DI based approaches.&lt;br /&gt;
1. We can provide support for as many Provides as we wish. Just implement AddressVerificationServiceProvider and inject it.&lt;br /&gt;
2. We can unit test using Dummy Data using Mock Implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;So by following Dependency Injection principle we can create interface-based loosely-coupled and easily testable services.&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;_&lt;br /&gt;
_&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Best Practices : Building Safe Domain Objects</title>
      <link>http://sivalabs.github.io/post/2012/java-best-practices-building-safe-domain-objects/</link>
      <pubDate>Mon, 16 Jan 2012 12:56:00 +0000</pubDate>
      
      <guid>http://sivalabs.github.io/post/2012/java-best-practices-building-safe-domain-objects/</guid>
      <description>&lt;p&gt;Domain objects are the core building blocks of any application. These are the fine grained objects which carries the information about the problem domain model.&lt;br /&gt;
Generally domain objects will be created as dumb data carriers with setters/geters without having any logic. But this will cause huge problem in long run.&lt;br /&gt;
If you build the domain objects with dumb setters and getters we will end up in writing null checks all over the places.&lt;/p&gt;

&lt;p&gt;I bet many of us have seen the code snippets like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User user = ....;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;if(user!=null)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;{&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; String email = user.getEmail();&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; if(email != null &amp;amp;&amp;amp; StringUtils.trimToNull(email) != null)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  emailService.sendEmail(....);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; else&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  throw new Exception(&amp;quot;Email should not be null/blank&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;}&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here email address of User object should not be null at all(It could be a not null property in database).&lt;/p&gt;

&lt;p&gt;But with dumb domain objects with only setters/getters we will end up writing code to check for nulls as mentioned above.&lt;/p&gt;

&lt;p&gt;We can get rid of this null checks in all over the places we can use Builder pattern.&lt;/p&gt;

&lt;p&gt;Assume we need to write a domain Object User with properties id, firstname, lastname, email, dob, phone.&lt;br /&gt;
Among them id, firstname, lastname, email properties are mandatory and should not be null or blank.&lt;/p&gt;

&lt;p&gt;In this case we can write the User class using Builder pattern as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.sivalabs.core.model;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;import java.util.Date;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;/**&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; * @author Siva&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; *&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; */&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;public class User &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;{&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private Integer id;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private String firstname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private String lastname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private String email;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private Date dob;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private String phone;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private User()&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; private User(Integer id, String firstname, String lastname, String email) &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.id = id;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.firstname = firstname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.lastname = lastname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.email = email;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public static final User build(Integer id, String firstname, String lastname, String email)&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(id == null || id &amp;lt; 0){&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   throw new IllegalArgumentException(&amp;quot;Id should not be null or negetive.&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(firstname == null || firstname.trim().length()==0){&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   throw new IllegalArgumentException(&amp;quot;firstname should not be null or blank.&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(lastname == null || lastname.trim().length()==0){&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   throw new IllegalArgumentException(&amp;quot;lastname should not be null or blank.&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(email == null || email.trim().length()==0){&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   throw new IllegalArgumentException(&amp;quot;email should not be null or blank.&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  if(!email.contains(&amp;quot;@&amp;quot;)){&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;   throw new IllegalArgumentException(&amp;quot;Invalid email address.&amp;quot;);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return new User(id,firstname, lastname, email);&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public Integer getId() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return id;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; } &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public String getFirstname() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return firstname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public String getLastname() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return lastname;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public String getEmail() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return email;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public Date getDob() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return new Date(dob.getTime());&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public User dob(Date dob) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.dob = new Date(dob.getTime());&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return this;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public String getPhone() {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return phone;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; }&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; public User phone(String phone) {&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  this.phone = phone;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;  return this;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; } &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;}&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following are the steps to build safe domain objects:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Make default constructor as private preventing others creating empty instances.&lt;/strong&gt; ** **&lt;br /&gt;
&lt;strong&gt;2. Create a private parametrized constructor with mandatory arguments only.&lt;/strong&gt; ** **&lt;br /&gt;
&lt;strong&gt;3. Provide a public static build() method taking mandatory arguments, validate them and then build the object using parametrized constructor.&lt;/strong&gt; ** **&lt;br /&gt;
**4. Create setter methods (I have used Method chaining here) for optional properties. **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;With this procedure I need not check for nulls for the mandatory arguments becuase if I have a non-null user object means it contains valid values for mandatory properties.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next level of Don&#39;t Repeat Yourself(DRY) principle</title>
      <link>http://sivalabs.github.io/post/2011/next-level-of-dont-repeat-yourselfdry-principle/</link>
      <pubDate>Sun, 30 Jan 2011 18:46:00 +0000</pubDate>
      
      <guid>http://sivalabs.github.io/post/2011/next-level-of-dont-repeat-yourselfdry-principle/</guid>
      <description>&lt;p&gt;We are building the software applications using various languages for several years. Over the time new frameworks, new tools, new methodologies have came up. Especially in Java platform, now we have plenty of choices in each area following various design patterns and principles like MVC, FrontController etc.&lt;/p&gt;

&lt;p&gt;We have many development principles like KISS(Keep It Simple Stupid), DRY(Don&amp;rsquo;t Repeat Yourself) which encourages to write better code which is maintainable. Especially DRY principle is a very good one which every developer should understand and follow.&lt;/p&gt;

&lt;p&gt;The DRY principle is stated as **&amp;ldquo;Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.&amp;rdquo; **&lt;/p&gt;

&lt;p&gt;So the DRY principle is saying that if you need to write same piece of code at many places instead of copy-pasting make it as a separate method and use it wherever it is required. This is applying DRY at code level.&lt;/p&gt;

&lt;p&gt;I really really appreciate the Jakartha-Commons Utils authors for practically implementing DRY principle. Whenever i need a utility like some String operation, Date calculation, Regular expressions, Properties loading etc etc I just open the Jakartha-Commons website and i am sure i can find there what i need.&lt;br /&gt;
Even though each application has its own set of business requirements there are many things which are common to web/enterprise applications. Especially infrastructure code might be similar to many applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Now I think it is time to take DRY priciple to the next level, I mean to apply at functional level.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let us see where we can apply DRY at functional level. The following are some of the things where we can build reusable components/small projects which we can directly use with other projects.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. An application multi-level menu bar:&lt;/strong&gt;&lt;br /&gt;
I have seen many applications having a horizantal menu bar at the top of the page with single/multi level sub-menus. The menu bar can be build using Javascript or custom tags. What I am suggesting is if we can build a CustomTag to generate a Menu bar from an xml configuration and a style sheet that component can be used in any of hte projects.&lt;/p&gt;

&lt;p&gt;For Ex:&lt;/p&gt;

&lt;p&gt;we can create an xml structure for our menu as follows and create a customtag to parse that xml and render a menu bar with default stylesheet. If user is proved a custom stylesheet that custom tag will use that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;menubar&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;menu&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        &amp;lt;index&amp;gt;1&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        &amp;lt;name&amp;gt;File&amp;lt;/name&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;index&amp;gt;1&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;name&amp;gt;New&amp;lt;/name&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;index&amp;gt;2&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;name&amp;gt;Save&amp;lt;/name&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            .....&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            .....&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    &amp;lt;/item&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/menu&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;    &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;menu&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        &amp;lt;index&amp;gt;2&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;        &amp;lt;name&amp;gt;Edit&amp;lt;/name&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;index&amp;gt;1&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;name&amp;gt;Cut&amp;lt;/name&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;            &amp;lt;item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;index&amp;gt;2&amp;lt;/index&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;                &amp;lt;name&amp;gt;Copy&amp;lt;/name&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;/menubar&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;/menu&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. Role-based authentication and authorization system:&lt;/strong&gt;&lt;br /&gt;
I involved in many projects where the application users will have one or more roles and each role has one or more privileges. Each privilege is nothing but an action that a use will do in appliation. The whole application events will driven by role based authorization. And also there could be a requirement to create user groups and assign privileges to user groups instead of individual users.&lt;/p&gt;

&lt;p&gt;I think this Role based Authorization System can also be built as a component which we can plug in to any project.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Job Scheduling:&lt;/strong&gt;&lt;br /&gt;
For many enterprises there could be several batch jobs that should be run on perticular schedules. I think there a need to build a job scheduling web application with the following features:&lt;br /&gt;
a) A web based UI to create and schedule new jobs&lt;br /&gt;
b) Provision to track the status of the running jobs&lt;br /&gt;
c) Provision to run jobs in adhoc manner&lt;br /&gt;
d) Provision to reschedule, terminate a job&lt;br /&gt;
e) Informing the concerned groups about the status of jobs through emails&lt;br /&gt;
f) Automatic email notifications on job failures&lt;/p&gt;

&lt;p&gt;we can build a web application with the above mentioned features and leaving business logic implementation in the jobs for the developers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Sophisticated logging system:&lt;/strong&gt;&lt;br /&gt;
While developing the application logging plays a vital role in debugging the problems. We can use AOP for logging in a better way with cleaner approach. Many times the developer needs to check what parameters are sending to methods and where it is throwing an exception.&lt;/p&gt;

&lt;p&gt;For this we can write MethodParamsDumbperAspect using SpringAOP+AspectJ which will display the method parameter values using reflection/commons-beanutils. Only thing a developer need to configure is the base package name.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Configurable and customizable work-flow engine&lt;/strong&gt;:&lt;br /&gt;
I have seen many intranet portals having HelpDesk applications with the following features.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A customer will raise a request.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The system will identify the workflow to process the request and the request will be routed to the concern person.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The requester can view the status of his request as each stpe is in progress.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Like this there are many WorkFlow based systems. We can build a generic workflow engine where in the administrator can setup the metadata like Request Types, Steps for each request, Request Status codes etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So here my point is all these days we followed DRY in writing code. Let us take it to the next level in building components/sub-projects. If an architect or developer got a requirement to build a reusable component, it would be great if he/she can publish his/her approach (and code if possible) so that the other developers across the java community can use the approach/code instead of reinventing the wheel.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I am planning to build a JobScheduling Server with the above mentioned features. If anyone is interested you can join me :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is Inversion Of Control (IOC)?</title>
      <link>http://sivalabs.github.io/post/2008/what-is-inversion-of-control-ioc/</link>
      <pubDate>Sun, 21 Dec 2008 10:09:00 +0000</pubDate>
      
      <guid>http://sivalabs.github.io/post/2008/what-is-inversion-of-control-ioc/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Inversion Of Control&lt;/strong&gt; is a design pattern which suggests the creation of collaborating objects and injecting them should not be done by the dependent object itself.&lt;/p&gt;

&lt;p&gt;For example, Suppose WhetherController(Servlet) is depend on WhetherService which is depend WhetherDAO.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;WhetherController .java&lt;/strong&gt;&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherController extends HttpServlet&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**protected doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException **&lt;br /&gt;
**{ **&lt;br /&gt;
**WhetherService service = new WhetherService(); **&lt;br /&gt;
&lt;strong&gt;service.doSomething(params);&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;….&lt;/strong&gt;&lt;br /&gt;
**…. **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;WhetherService.java&lt;/strong&gt;&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherService&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**public void doSomething(Map params) **&lt;br /&gt;
**{ **&lt;br /&gt;
&lt;strong&gt;WhetherDAO dao = new WhetherDAO();&lt;/strong&gt;&lt;br /&gt;
**dao.getWhetherReport(); **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;WhetherDAO.java&lt;/strong&gt;&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherDAO&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
&lt;strong&gt;// code to interact with Database&lt;/strong&gt;&lt;br /&gt;
**} **&lt;br /&gt;
**&lt;/p&gt;

&lt;p&gt;**If you code as said above and if it is a big project you may use WhetherService/WhetherDAO in several classes. Later on, Suppose due to some reasons you need to change the WhetherService/WhetherDAO class as follows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;WhetherService.java&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherService&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private WhetherService whetherService = new WhetherService(); **&lt;br /&gt;
**private WhetherService(){ } **&lt;br /&gt;
**public WhetherService getWhetherService() **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
**return whetherService; **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;WhetherDAO.java&lt;/strong&gt;&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherDAO&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private JDBCConnection connection = null; **&lt;br /&gt;
**public WhetherDAO(JDBCConnection connection) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
**this.connection = connection; **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;// code to interact with Database&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;Then as you are already using WhetherService/WhetherDAO classes in several places you need to make changes in several classes, which is cumbersome task.&lt;/p&gt;

&lt;p&gt;The mail flaw in this design is WhetherController servlet is taking the responsibilty of creating WhetherService instances and WhetherService class is taking the responsibilty of creating WhetherDAO objects. Thereby your classes are tightly coupled.&lt;/p&gt;

&lt;p&gt;To get rid of this problem, The IOC(Inversion Of Control) Design patetern suggests that have a Container which is responsible for creation of objects and their dependent objects and injecting them and serve them. When the client requested an object from the container, the container will give full fledzed objects with all dependencies set.&lt;/p&gt;

&lt;p&gt;Let us see how we can change the above design by following IOC design pattern.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;WhetherController .java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;class WhetherController extends HttpServlet&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private WhetherService whetherService; **&lt;br /&gt;
**public void setWhetherService(WhetherService whetherService) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
**this.whetherService = whetherService; **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protected doPost(HttpServletRequest req, HttpServletResponse res) throws IOException,ServletException&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**this.whetherService.doSomething(params); **&lt;br /&gt;
&lt;strong&gt;….&lt;/strong&gt;&lt;br /&gt;
**…. **&lt;br /&gt;
**} **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;WhetherService.java&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherService&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private WhetherDAO whetherDAO ; **&lt;br /&gt;
**public void setWhetherDAO(WhetherDAO whetherDAO) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
**this.whetherDAO =whetherDAO; **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**public void doSomething(Map params) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;this.whetherDAO.getWhetherReport();&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;WhetherDAO.java&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;class WhetherDAO&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private JDBCConnection connection = null; **&lt;br /&gt;
**public WhetherDAO(JDBCConnection connection) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
**this.connection = connection; **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;// code to interact with Database&lt;/strong&gt;&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Container.java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public class Container&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**private static Map objectMap = new HashMap();&lt;br /&gt;
static **&lt;br /&gt;
**{ **&lt;br /&gt;
**JDBCConnection connection = new JDBCConnection(); **&lt;br /&gt;
**objectMap.put(”connection”,connection); **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**WhetherDAO whetherDAO = new WhetherDAO(connection); **&lt;br /&gt;
**objectMap.put(”whetherDAO”,whetherDAO); **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**WhetherService whetherService = new WhetherService(); **&lt;br /&gt;
**whetherService.setWhetherDAO(whetherDAO); **&lt;br /&gt;
**objectMap.put(”whetherService”,whetherService); **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**} **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**public static Object getObject(String objectId) **&lt;br /&gt;
&lt;strong&gt;{&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Object obj = objectMap.get(objectId);&lt;/strong&gt;&lt;br /&gt;
**if(obj==null) **&lt;br /&gt;
**{ **&lt;br /&gt;
**throw new RuntimeException(”Invalid objectId is given”); **&lt;br /&gt;
&lt;strong&gt;} return obj;&lt;/strong&gt;&lt;br /&gt;
**} **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;p&gt;Now the WhetherController servlet can be changed as follows:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;WhetherController .java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;class WhetherController extends HttpServlet&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
&lt;strong&gt;private WhetherService whetherService;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**public WhetherController() **&lt;br /&gt;
**{ **&lt;br /&gt;
&lt;strong&gt;WhetherService whetherService =(WhetherService)&lt;/strong&gt;&lt;br /&gt;
**Container.getObject(”whetherService”); **&lt;br /&gt;
**setWhetherService(whetherService); **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;public void setWhetherService(WhetherService whetherService)&lt;/strong&gt;&lt;br /&gt;
**{ **&lt;br /&gt;
**this.whetherService = whetherService; **&lt;br /&gt;
**} **&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;**protected doPost(HttpServletRequest req, HttpServletResponse res) throws IOException,ServletException **&lt;br /&gt;
**{ **&lt;br /&gt;
**this.whetherService.doSomething(params); **&lt;br /&gt;
**…. **&lt;br /&gt;
**…. **&lt;br /&gt;
**} **&lt;br /&gt;
&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now if you need to change the way of object creation the only place we need to modify Container class only.&lt;/p&gt;

&lt;p&gt;Today there are several IOC container are available implemented using Java such as Spring, Pico etc.Among them Spring becomes very much popular as it is not only the IOC container.&lt;/p&gt;

&lt;p&gt;Spring became an Application Framework which provides several features in all the layers such as web/service/dao layers. Unlike the other frameworks like Struts/Hibernate, Spring is not limited to only Web/Persistence layers. And one more great feature of Spring is pluggability with other frameworks.&lt;/p&gt;

&lt;p&gt;Spring can be used with several other pupular frameworks like Struts1.x, Struts2,JSF, WebWork,IBatis,Hibernate, EJB etc.&lt;/p&gt;

&lt;p&gt;For more information on Spring,visit &lt;a href=&#34;http://static.springframework.org/spring/docs/2.5.x/reference/index.html&#34;&gt;http://static.springframework.org/spring/docs/2.5.x/reference/index.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>